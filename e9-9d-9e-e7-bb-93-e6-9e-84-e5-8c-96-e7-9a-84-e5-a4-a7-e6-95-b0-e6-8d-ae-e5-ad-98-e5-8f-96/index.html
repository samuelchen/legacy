<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>&gt;非结构化的大数据存取 - Legacy - Explorer. Dream. Discover.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;gt;前两天和朋友聊到一个有意思的话题，那就是非结构化的大数据如何去存储。内容大概是这样： 一个数据库系统可以实现非结构化的存储，其方法是采用xml来定义数据，并将数据作为一个大数据字段。那么问题来了，当这个字段特别大的时候，比如1G，不能简单的载入到内存中，那么我们应该怎么做？">
<meta name="keywords" content="Architect,Programming,Technology,Articles,Database">
<meta property="og:type" content="article">
<meta property="og:title" content="&gt;非结构化的大数据存取">
<meta property="og:url" content="http://blog.samuelchen.net/legacy/e9-9d-9e-e7-bb-93-e6-9e-84-e5-8c-96-e7-9a-84-e5-a4-a7-e6-95-b0-e6-8d-ae-e5-ad-98-e5-8f-96/index.html">
<meta property="og:site_name" content="Legacy - Explorer. Dream. Discover.">
<meta property="og:description" content="&amp;gt;前两天和朋友聊到一个有意思的话题，那就是非结构化的大数据如何去存储。内容大概是这样： 一个数据库系统可以实现非结构化的存储，其方法是采用xml来定义数据，并将数据作为一个大数据字段。那么问题来了，当这个字段特别大的时候，比如1G，不能简单的载入到内存中，那么我们应该怎么做？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-12T05:56:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="&gt;非结构化的大数据存取">
<meta name="twitter:description" content="&amp;gt;前两天和朋友聊到一个有意思的话题，那就是非结构化的大数据如何去存储。内容大概是这样： 一个数据库系统可以实现非结构化的存储，其方法是采用xml来定义数据，并将数据作为一个大数据字段。那么问题来了，当这个字段特别大的时候，比如1G，不能简单的载入到内存中，那么我们应该怎么做？">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/legacy/legacy/webfonts/ptserif/main.css" rel="stylesheet" type="text/css">
  <link href="/legacy/legacy/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/legacy/css/style.css">
  

</head></html>
<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <a id="logo" class="logo logo-text" href="/legacy/">Legacy Posts - Explore. Dream. Discover.</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/legacy/">Home</a>
        
          <a class="main-nav-link" href="/legacy/archives">Archives</a>
        
          <a class="main-nav-link" href="/legacy/categories">Categories</a>
        
          <a class="main-nav-link" href="/legacy/tags">Tags</a>
        
          <a class="main-nav-link" href="/legacy/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.samuelchen.net/legacy"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-e9-9d-9e-e7-bb-93-e6-9e-84-e5-8c-96-e7-9a-84-e5-a4-a7-e6-95-b0-e6-8d-ae-e5-ad-98-e5-8f-96" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      &gt;非结构化的大数据存取
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/legacy/e9-9d-9e-e7-bb-93-e6-9e-84-e5-8c-96-e7-9a-84-e5-a4-a7-e6-95-b0-e6-8d-ae-e5-ad-98-e5-8f-96/" class="article-date">
  <time datetime="2010-05-23T10:35:00.000Z" itemprop="datePublished">2010-05-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/legacy/categories/未分类/">未分类</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&gt;前两天和朋友聊到一个有意思的话题，那就是非结构化的大数据如何去存储。内容大概是这样：</p>
<div><br><div>一个数据库系统可以实现非结构化的存储，其方法是采用xml来定义数据，并将数据作为一个大数据字段。那么问题来了，当这个字段特别大的时候，比如1G，不能简单的载入到内存中，那么我们应该怎么做？</div><br><div><br><br><a id="more"></a><br><br>感觉这个挺有意思，就分析一下。<br><br>对于这个Feature，我们可以假定一些前提，<br><br>1、这是一个基于文件存储的数据库，并且该文件系统可以支持无限大的文件。<br><br>2、这个数据库系统是个key/value的，key是用于访问，value是用于存储真正的数据。key, value的访问api是基于行和位移的，其他的辅助信息不额外考虑。<br><br>3、数据是xml格式的，直接存储在value中。例如有个职员信息 info 是<br><div style="margin-left: 0px; margin-right: 0px;"></div><br><div style="font-family: 'Times New Roman'; margin-left: 0px; margin-right: 0px;"></div><br><span style="font-family: 'Courier New';"><span style="font-size: x-small;">&lt;fname&gt;Samuel&lt;/fname&gt;<br>&lt;lname&gt;Chen&lt;/lname&gt;<br>&lt;address&gt;<br>&lt;city&gt;Beijing&lt;/city&gt;<br>&lt;country&gt;China&lt;/country&gt;<br></span></span><span style="font-family: 'Courier New';"><span style="font-size: x-small;">&lt;/address&gt;<br>&lt;photo&gt;<br>&lt;![CDATA[<br>binary data of photo<br>]]&gt;<br>&lt;/photo&gt;</span></span><br><div><br><br>那么 <span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">select <em> from tab where fname = ‘Samuel’</em></span></span> 返回一个对象person（或文档对象），具有这么些个属性。（这种类型的数据库查询不一定适合用传统的关系型数据库的SQL，很有可能是xPath、query与SQL的结合，这里仅用来作为示意。）<br><br>问题来了，如果这个文档对象非常之大，达到了1G，那么当用户修改了一个字段，比如city变成了Shanghai，这样的一个功能，我们该如何实现？<br><br>分析一下，需要解决的问题有下面这么几个：<br><br>1、首先是大数据，再者是非结构化，也就是基于行列的存储是不合适的，那么该怎么存储才能使得空间足够也不浪费？<br><br>2、这么大的数据内容，直接载入到内存，显然是不太合适的，需要直接在文件中更新。<br><br>3、传统的关系型数据库操作只有CRUD，也就是增、删、查、改，其基本结构是字段，如果整个来更新是否合适？如果不整个更新，只更新修改的部分，怎么去实现。<br><br>按照这个思路，一个个来解决。<br><br>## 存取<br><br>一般来说，对于xml数据存储，是使用字符型blob（binary亦可）字段，可以防止空间浪费或不足。在用的时候读出，存的时候写入。那么当该xml文档非常大的时候，直接读取到内存中就不太现实，此时就需要直接在文件中访问。所以问题就成了这个key/value的系统怎么去设计才能完成这个任务。<br><br>要解决空间浪费或不足的问题，那么存储段就需要具有scalability，可以根据数据大小伸缩，因此可以将其设计成分段的，当需要的时候增加，不需要的时候就释放，如下<br><span style="font-size: small;"><br></span><br><table id="xtrn" border="1" cellspacing="2" cellpadding="2"><br><tbody><br><tr><br><td width="12.5%"><span style="font-size: xx-small;">sequence</span></td><br><td width="12.5%"><span style="font-size: xx-small;">key</span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="font-size: xx-small;">structure</span><br></span></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"><span style="font-size: xx-small;">value</span></td><br></tr><br><tr><br><td width="12.5%"><span style="font-size: xx-small;">offset</span></td><br><td width="12.5%"><span style="font-size: xx-small;">we don’t care</span></td><br><td width="12.5%"><span style="font-size: xx-small;">head</span></td><br><td width="12.5%"><span style="font-size: xx-small;">length</span></td><br><td width="12.5%"><span style="font-size: xx-small;">next</span></td><br><td width="12.5%"><span style="font-size: xx-small;">deleted</span></td><br><td width="12.5%"><span style="font-size: xx-small;">actual length</span></td><br><td width="12.5%"><span style="font-size: xx-small;">data</span></td><br></tr><br><tr><br><td width="12.5%"><span style="font-size: xx-small;">4B</span></td><br><td width="12.5%"><span style="font-size: xx-small;">2B + 4KB</span></td><br><td width="12.5%"><span style="font-size: xx-small;">1B (1b)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">16B(16777216TB)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">4B</span></td><br><td width="12.5%"><span style="font-size: xx-small;">1B (1b)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">2B(max=64KB)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">64KB<br></span></td><br></tr><br><tr><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br><td width="12.5%"></td><br></tr><br><tr><br><td width="12.5%"><span style="font-size: xx-small;">0x00000001</span></td><br><td width="12.5%"></td><br><td width="12.5%"><span style="font-size: xx-small;">1</span></td><br><td width="12.5%"><span style="font-size: xx-small;">143360(140K)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0x00000002 </span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">65536(64KB)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xxx</span></td><br></tr><br><tr><br><td width="12.5%"><span style="font-size: xx-small;">0x00000002</span></td><br><td width="12.5%"></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">143360</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0x00000003</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">65536</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xxx</span></td><br></tr><br><tr><br><td width="12.5%"><span style="font-size: xx-small;">0x00000003</span></td><br><td width="12.5%"></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">143360</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">12288(12KB)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xx</span></td><br></tr><br></tbody><br></table><br>如表格所示，key 是固定长度字段，我们在这里并不关心，所需的只是其长度，假定其总长度为 key_len.<br><br>Sequence 是每一个record的首地址，可以记录，也可以不记录，列在这里是因为我们需要这个值来做为基本偏移量。<br><br>Structure 是每个value所需要的信息，包括是否第一个数据段（head），value 总长是多少（length），下一个段偏移量（next），是否已经删除（deleted），以及本段真实长度（actual length）。通过这些，我们就可以通过计算来访问一块完整数据。<br><br>Value 是存储的真实数据，当然也可以有一些其他信息，比如encoding之类。<br><br>那么有了这么一个系统，我们就可以存储任意大小的数据（最大长度由length或者系统定义决定，本例中是16777216TB，实际上目前没这么大的）.<br><br>例如我们有一块140KB的数据，那么存储的时候会分成如表格所示3段存储，前两段是满存储，最后一段存了12KB，有一定浪费，因此分段大小也是需要考虑的，过大过小都不好（4~8K比较合适），也可以通过让用户配置来决定。当然，如果用一个单独的文件来存储，甚至可以不必分段，只需维护一个偏移+长度表即可，这里就不讨论这种方法了。<br><br>当需要修改时，如果数据长度增加了，变成了200KB，我们就可以通过修改偏移量、长度，并增加新段来解决，如表<br><span style="font-size: small;"><br></span><br><table id="fw66" border="1" cellspacing="2" cellpadding="2"><br><tbody><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;">0x00000001</span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">1</span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">204800(200K)</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0x00000002 </span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">65536(64KB)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xxx</span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;">0x00000002</span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="color: blue;"><span style="font-size: xx-small;">204800</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0x00000003</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">65536</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xxx</span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;">0x00000003</span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="color: blue;"><span style="font-size: xx-small;">204800</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">0x00000005</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">65536</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;">xxx</span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">0x00000004</span></span></td><br><td width="12.5%"></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">1</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">10240</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">0</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">0</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">10240</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">yyy</span></span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">0x00000005</span></span></td><br><td width="12.5%"></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">0</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">204800</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">0</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">0</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">8192</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;">xx</span></td><br></tr><br></tbody><br></table><br></div><br><div><br><br>同样的，删除也可以通过标记段已删除来实现，下次再变大的时候，可以继续使用，或者用新的段来代替。多次删除之后，可能会有大量的删除段存在，这就需要重整，亦或使用其他方法来防止大量删除段的出现。这些细节以及实现在这里暂不细说了。<br><br>这样，我们就解决了第一个问题，如何去存储这种非结构化大数据。当然，各个数据库都有自己的实现，性能优劣各不相同，也可参考。<br><br>## 访问<br><br>数据库访问一般来说都是由各数据库厂商提供api，比如oracle的OCI/Pro C。 也有一些通用的包装，如ODBC，JDBC等。无论是哪种方式，当你在程序中使用的时候，访问的都是内存中的buffer，例如<br><span style="font-size: small;"><br></span><br><table id="w386" border="1" cellspacing="2" cellpadding="2"><br><tbody><br><tr style="text-align: left;"><br><td bgcolor="#cccccc" width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">id</span></span></span></td><br><td bgcolor="#cccccc" width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">emp_id</span></span></span></td><br><td bgcolor="#cccccc" width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">dept</span></span></span></td><br><td bgcolor="#cccccc" width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">info</span></span></span></td><br></tr><br><tr style="text-align: left;"><br><td width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">9527</span></span></span></td><br><td width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">samc</span></span></span></td><br><td width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">PB</span></span></span></td><br><td width="25%"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&lt;fname&gt;Samuel&lt;/fname&gt;<br>&lt;lname&gt;Chen&lt;/lname&gt;<br>&lt;address&gt;<br>&lt;city&gt;Beijing&lt;/city&gt;<br>&lt;country&gt;China&lt;/country&gt;</span></span></span><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px;"><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&lt;/address&gt;<br>&lt;photo&gt;<br>&lt;![CDATA[<br>binary data of photo<br>]]&gt;<br>&lt;/photo&gt;</span></span></span></td><br></tr><br></tbody><br></table><br>此时的各个字段如 id, emp_id, dept 都是存在于内存的buffer之中，当你使用api访问行、列或者名字的时候（比如ado的recordset），api会计算并返回相应的值。<br><br>当碰到非常大的数据时，怎么办？比如info里面有个人信息，还包括照片等等，达到了几十、百兆甚至上G，那么一个查询取出几百条数据，总共的数据超过了内存限制，该怎么办？<br><br>这个问题涉及到了两个层面，一个是多行数据过大，一个是单个数据过大。对于第一个问题，多行数据过大，一般来说API都有考虑，会再访问的时候再去取，或者预读等等，暂且不提，这里咱们讨论第二个问题。<br><br>其实单个数据的访问也是可以在访问的时候去取的，也就是所谓的access on demand。我们可以在buffer该数据内容中存储访问信息而不是真实数据，在真正用户用到的时候再去数据库取，如表<br><span style="font-size: small;"><br></span><br><table id="lt.t" border="1" cellspacing="2" cellpadding="2"><br><tbody><br><tr style="text-align: left;"><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">id</span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">emp_id</span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">dept<br></span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">info</span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">info_data</span></td><br></tr><br><tr style="text-align: left;"><br><td width="20%"><span style="font-size: xx-small;">9527</span></td><br><td width="20%"><span style="font-size: xx-small;">samc</span></td><br><td width="20%"><span style="font-size: xx-small;">PB</span></td><br><td width="20%"><br><div><span style="font-size: xx-small;">key | offset | len | …</span></div></td><br><td width="20%"><span style="font-size: xx-small;">null </span></td><br></tr><br></tbody><br></table><br></div><br><div>这样，在访问到的时候，将数据从磁盘读到内存，并更新内存buffer为：</div><br><div><br><table id="p4j7" border="1" cellspacing="2" cellpadding="2"><br><tbody><br><tr style="text-align: left;"><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">id</span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">emp_id</span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">dept<br></span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">info</span></td><br><td bgcolor="#cccccc" width="20%"><span style="font-size: xx-small;">info_data</span></td><br></tr><br><tr style="text-align: left;"><br><td width="20%"><span style="font-size: xx-small;">9527</span></td><br><td width="20%"><span style="font-size: xx-small;">samc</span></td><br><td width="20%"><span style="font-size: xx-small;">PB</span></td><br><td width="20%"><br><div><span style="font-size: xx-small;">loaded…</span></div></td><br><td width="20%"><span style="font-size: xx-small;"><span style="color: blue;">0x03677d2d </span>-&gt;</span></td><br></tr><br></tbody><br></table><br>当然，这个内存结构和存储的信息可以根据实际情况来定义。<br><br>无可否认的是，这个方法是有效率问题的，时间换空间。可以根据实际情况考虑采用预读，比如当用户使用单向遍历（如ado.net的IDataReader）时，可以在内存允许的范围内预读接下来的N条。<br><br>## 修改<br><br>还是这个例子，如果我们修改了个人信息，把city改为Shanghai，按照传统做法，是要update info，把整个info字段更新一下。<br><span style="font-size: small;"><br></span><br><div><br><br><span style="font-size: small;"><span style="font-family: 'Courier New';"><span style="font-size: x-small;">&lt;fname&gt;Samuel&lt;/fname&gt;<br>&lt;lname&gt;Chen&lt;/lname&gt;<br>&lt;address&gt;<br>&lt;city&gt;<span style="color: blue;">Shanghai</span>&lt;/city&gt;<br>&lt;country&gt;China&lt;/country&gt;<br></span></span><span style="font-family: 'Courier New';"><span style="font-size: x-small;">&lt;/address&gt;<br>&lt;photo&gt;<br>&lt;![CDATA[<br>binary data of photo<br>]]&gt;<br>&lt;/photo&gt;</span></span></span><br><br>&nbsp;<br><br></div><br>那么在该数据系统中，仅仅因为更新了整块数据中非常小的一部分（几个字节），我们就需要修改整块大数据（1G），这是非常影响效率的。<br><br>因此，我们可以计算该修改的位置，看它是处于哪一个数据块，而仅仅修改一个数据段，从而大幅提高效率。同时，如果修改的范围过大，可以考虑整个更新。这些都需要记录修改的信息来实现。<br><br></div><br><span style="font-size: small;"><br></span><br><table id="dvm5" border="1" cellspacing="2" cellpadding="2"><br><tbody><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;">0x00000001</span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">1</span></td><br><td width="12.5%"><span style="font-size: xx-small;">204800(200K)</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0x00000002 </span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">65536(64KB)</span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: blue;">xxx （仅修改该段）</span></span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;">0x00000002</span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">204800</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0x00000003</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">65536</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xxx</span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;">0x00000003</span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">204800</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0x00000005</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">65536</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xxx</span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">0x00000004</span></span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">1</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">10240</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">0</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">0</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">10240</span></span></td><br><td width="12.5%"><span style="font-size: xx-small;"><span style="color: #999999;">yyy</span></span></td><br></tr><br><tr style="text-align: left;"><br><td width="12.5%"><span style="font-size: xx-small;">0x00000005</span></td><br><td width="12.5%"><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">204800</span><span style="font-size: small;"><br></span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">0</span></td><br><td width="12.5%"><span style="font-size: xx-small;">8192</span></td><br><td width="12.5%"><span style="font-size: xx-small;">xx</span></td><br></tr><br></tbody><br></table><br><br>## <span class="Apple-style-span" style="font-size: medium; font-weight: normal;">以上的方法可以适用于binary或者字符blob，但是，由于在这个case中，我们考虑的是xml数据，所以需要有一些更进一步的细节考虑。比如根据xml parser实现的不同，数据不一定是按节点顺序存放的，而且节点也不一定是有序的。因此，需要在每个节点的meta中存储段信息（或者其他的方法，根据xml parser/dom的不同具体考虑）</span><br><br>## 总结<br><br><span style="font-size: small;">这样，我们就能够很好的处理非结构化大数据的存储和访问了。</span><br><br>当然，这只是个原型，还有数据库的transaction，log等等许多问题需要考虑，同时perfomance也需要长时间的优化。<span style="font-size: small;"><br></span><br><br></div><br></div>
      
    </div>
  
    <footer class="article-footer">
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/legacy/tags/Architect/">Architect</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/legacy/tags/Articles/">Articles</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/legacy/tags/Database/">Database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/legacy/tags/Programming/">Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/legacy/tags/Technology/">Technology</a></li></ul>

    </footer>
  
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/legacy/net-frameowrk-4-0-compatibility/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">&gt;.Net Frameowrk 4.0 Compatibility&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Samuel Chen&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/legacy/legacy/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/legacy/fancybox/jquery.fancybox.css">
  <script src="/legacy/fancybox/jquery.fancybox.pack.js"></script>


<script src="/legacy/js/script.js"></script>
  </div>
</body>
</html>